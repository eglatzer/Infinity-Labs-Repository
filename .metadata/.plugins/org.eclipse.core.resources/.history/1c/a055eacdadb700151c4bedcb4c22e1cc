package com.ilad.pair;

public class Pair<K, V extends Comparable<V>> {
	private K key;
	private V value;
	
	// Constructor
	public Pair(K key_, V value_) {
		key = key_;
		value = value_;
	}

	// Getters and Setters
	public K getKey() {
		return key;
	}

	public void setKey(K key_) {
		key = key_;
	}

	public V getValue() {
		return value;
	}

	public void setValue(V value_) {
		value = value_;
	}

	// Equals Method
	public boolean equals(Pair<K, V> obj) {
		if(this == obj)
			return true;
		if(obj == null)
			return false;
		if(getClass() != obj.getClass())
			return false;
		if(key == null) {
			if(obj.key != null)
				return false;
		} else if(!key.equals(obj.key))
			return false;
		if(value == null) {
			if(obj.value != null)
				return false;
		} else if(!value.equals(obj.value))
			return false;
		return true;
	}
	
	// CompareTo Method
	public double compareTo(Pair<K, V> obj) {
		return value.compareTo(obj.value);
	}

	// HashCode Method
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((key == null) ? 0 : key.hashCode());
		result = prime * result + ((value == null) ? 0 : value.hashCode());
		return result;
	}
	
	// ToString Method
	@Override
	public String toString() {
		return "pair: key = " + key + ", value = " + value;
	}
	
	// Swap Method
	public static <R extends Comparable<R>, T extends Comparable<T>> Pair<T, R> swap(Pair<R, T> obj) {
		return new Pair<T, R>(obj.value, obj.key);
	}
	
	// Of Method (Factory Method)
	public static <R, T extends Comparable<T>> Pair<R, T> of(R key, T value) {
		return new Pair<R, T>(key, value);
	}
	
	// Minmax Method
	public static <R extends Comparable<R>, T extends Comparable<T>> Pair<T, T> minmax(Pair<R, T>[] obj) {
		T min = obj[0].value;
		T max = obj[0].value;
		
		for(int i = 1; i < obj.length; ++i) {
			if(0 > obj[i].value.compareTo(min)) {
				min = obj[i].value;
			}
			else if(0 < obj[i].value.compareTo(max)) {
				max = obj[i].value;
			}
		}
		
		return new Pair<T, T>(min, max);
	}
}
