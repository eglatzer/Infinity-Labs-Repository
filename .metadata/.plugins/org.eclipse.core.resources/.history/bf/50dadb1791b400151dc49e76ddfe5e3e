package com.ilad.circularbuffer;

import javax.crypto.IllegalBlockSizeException;

public class CircularBuffer<E> {
	private E[] circularBuffer;
	private int memCapacity;
	private int memUsed = 0;
	private int readIndex = 0;

	// Constructor
	@SuppressWarnings("unchecked")
	public CircularBuffer(int memCapacity_) throws IllegalBlockSizeException {
		if (0 >= memCapacity_) {
			throw new IllegalBlockSizeException("memCapacity_ should be positive!");
		}
		Object temp = new Object[memCapacity_];
		circularBuffer = (E[])temp;
		memCapacity = memCapacity_;
	}

	// Getters
	private E getCircularBufferElementAt(int index) {
		if(index >= memUsed || index < 0) {
			throw new OutOfMemoryError("index is out of memUsed bounds!");
		}
		return circularBuffer[index];
	}
	
	public int getMemCapacity() {
		return memCapacity;
	}

	public int getMemUsed() {
		return memUsed;
	}

	public int getMemFree() {
		return memCapacity - memUsed;
	}

	private int getWriteIndex() {
		return (readIndex + memUsed) % memCapacity;
	}

	// Other Methods
	public int read(E[] outerBuffer, int memToRead) {
		int i = 0;
		while(0 != memUsed && i != outerBuffer.length && i != memToRead) {
			outerBuffer[i] = circularBuffer[readIndex];
			++i;
			--memUsed;
			readIndex = (readIndex + 1) % memCapacity;
		}
		return i;
	}

	public int write(E[] outerBuffer, int memToWrite) {
		int i = 0;
		while(0 != getMemFree() && i != outerBuffer.length && i != memToWrite) {
			circularBuffer[getWriteIndex()] = outerBuffer[i];
			++i;
			++memUsed;
		}
		return i;
	}
	
	public String toString() {
		String string = "";
		for(int i = 0; i < memUsed; ++i) {
			string.concat(getCircularBufferElementAt(i) + " ");
		}
		return string;
	}
}
