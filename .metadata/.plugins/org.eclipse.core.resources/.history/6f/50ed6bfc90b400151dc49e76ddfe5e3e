package com.ilad.circularbuffer;

import javax.crypto.IllegalBlockSizeException;

public class CircularBuffer<E> {
	private E[] circularBuffer;
	private int memCapacity;
	private int memUsed = 0;
	private int readIndex = 0;

	// Constructor
	@SuppressWarnings("unchecked")
	public CircularBuffer(int memCapacity_) throws IllegalBlockSizeException {
		if (0 >= memCapacity_) {
			throw new IllegalBlockSizeException("memCapacity_ should be positive!");
		}
		Object temp = new Object[memCapacity_];
		circularBuffer = (E[])temp;
		memCapacity = memCapacity_;
	}

	// Getters
	public int getMemCapacity() {
		return memCapacity;
	}

	public int getMemUsed() {
		return memUsed;
	}

	public int getMemFree() {
		return memCapacity - memUsed;
	}

	private int getWriteIndex() {
		return (readIndex + memUsed) % memCapacity;
	}

	// Other Methods
	public int read(E[] outerBuffer, int memToRead) {
		int i = 0;
		while(0 != memUsed && i != outerBuffer.length && i != memToRead) {
			outerBuffer[i] = circularBuffer[readIndex];
			++i;
			--memUsed;
			readIndex = (readIndex + 1) % memCapacity;
		}
		return i;
	}

	public int write(E[] outerBuffer, int memToWrite) {
		int i = 0;
		while(0 != getMemFree() && i != outerBuffer.length && i != memToWrite) {
			circularBuffer[getWriteIndex()] = outerBuffer[i];
			++i;
			++memUsed;
		}
		return i;
	}
}
