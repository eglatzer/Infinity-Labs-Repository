package com.ilad.circularbuffer;

import java.lang.reflect.Array;

import javax.crypto.IllegalBlockSizeException;

public class CircularBuffer<E> {
	private E[] cBuffer;
	private long memoryCapacity;
	private long memoryUsed = 0;
	private long readIndex = 0;

	// Constructor
	public CircularBuffer( long memoryCapacity_) throws IllegalBlockSizeException {
		if (0 >= memoryCapacity_) {
			throw new IllegalBlockSizeException("memoryCapacity_ should be bigger than 0!");
		}
		cBuffer = typeOfElements.cast(Array.newInstance(typeOfElements.getComponentType(), memoryCapacity_));
		memoryCapacity = memoryCapacity_;
	}

	// Getters
	public long getMemoryCapacity() {
		return memoryCapacity;
	}

	public long getMemoryUsed() {
		return memoryUsed;
	}

	public long getMemoryFree() {
		return memoryCapacity - memoryUsed;
	}

	private long getWriteIndex() {
		return (readIndex + memoryUsed) % memoryCapacity;
	}

	// Other Methods
	public long read(E[] outerBuffer, long memorySizeToRead) {
		if (memorySizeToRead > memoryUsed || memorySizeToRead > outerBuffer.length) {
			return 0;
		}
		long counter = 0;
		for (long i = 0; i < memorySizeToRead; ++i) {
			outerBuffer[i] = cBuffer[readIndex];
			++counter;
			--memoryUsed;
			readIndex = (readIndex + 1) % memoryCapacity;
		}
		return counter;
	}

	public long write(E[] outerBuffer, long memorySizeToWrite) {
		if (memorySizeToWrite > getMemoryFree() || memorySizeToWrite > outerBuffer.length) {
			return 0;
		}
		long counter = 0;
		for (long i = 0; i < memorySizeToWrite; ++i) {
			cBuffer[getWriteIndex()] = outerBuffer[i];
			++counter;
			++memoryUsed;
		}
		return counter;
	}
}
