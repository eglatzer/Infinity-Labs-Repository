package com.ilad.circularbuffer;

import javax.crypto.IllegalBlockSizeException;

public class CircularBuffer<E> {
	private E[] cBuffer;
	private int memCapacity;
	private int memUsed = 0;
	private int readIndex = 0;

	// Constructor
	@SuppressWarnings("unchecked")
	public CircularBuffer(int memCapacity_) throws IllegalBlockSizeException {
		if (0 >= memCapacity_) {
			throw new IllegalBlockSizeException("memCapacity_ should be positive!");
		}
		Object temp = new Object[memCapacity_];
		cBuffer = (E[])temp;
		memCapacity = memCapacity_;
	}

	// Getters
	public int getMemCapacity() {
		return memCapacity;
	}

	public int getMemUsed() {
		return memUsed;
	}

	public int getMemFree() {
		return memCapacity - memUsed;
	}

	private int getWriteIndex() {
		return (readIndex + memUsed) % memCapacity;
	}

	// Other Methods
	public boolean read(E[] oBuffer, int memToRead) {
		if (memToRead > memUsed || memToRead > oBuffer.length) {
			return false;
		}
		for (int i = 0; i < memToRead; ++i) {
			oBuffer[i] = cBuffer[readIndex];
			--memUsed;
			readIndex = (readIndex + 1) % memCapacity;
		}
		return true;
	}

	public boolean write(E[] oBuffer, int memToWrite) {
		if (memToWrite > getMemFree() || memToWrite > oBuffer.length) {
			return false;
		}
		for (int i = 0; i < memToWrite; ++i) {
			cBuffer[getWriteIndex()] = oBuffer[i];
			++memUsed;
		}
		return true;
	}
}
