package com.ilad.circularbuffer;

import javax.crypto.IllegalBlockSizeException;

public class CircularBuffer<E> {
	private E[] cBuffer;
	private int memoryCapacity;
	private int memoryUsed = 0;
	private int readIndex = 0;

	// Constructor
	@SuppressWarnings("unchecked")
	public CircularBuffer(int memoryCapacity_) throws IllegalBlockSizeException {
		if (0 >= memoryCapacity_) {
			throw new IllegalBlockSizeException
				("memoryCapacity_ should be bigger than 0!");
		}
		Object temp = new Object[memoryCapacity_];
		cBuffer = (E[])temp;
		memoryCapacity = memoryCapacity_;
	}

	// Getters
	public int getMemoryCapacity() {
		return memoryCapacity;
	}

	public int getMemoryUsed() {
		return memoryUsed;
	}

	public int getMemoryFree() {
		return memoryCapacity - memoryUsed;
	}

	private int getWriteIndex() {
		return (readIndex + memoryUsed) % memoryCapacity;
	}

	// Other Methods
	public boolean read(E[] outerBuffer, int memoryToRead) {
		if (memoryToRead > memoryUsed || memoryToRead > outerBuffer.length) {
			return false;
		}
		for (int i = 0; i < memoryToRead; ++i) {
			outerBuffer[i] = cBuffer[readIndex];
			--memoryUsed;
			readIndex = (readIndex + 1) % memoryCapacity;
		}
		return true;
	}

	public boolean write(E[] outerBuffer, int memoryToWrite) {
		if (memoryToWrite > getMemoryFree() || memoryToWrite > outerBuffer.length) {
			return false;
		}
		for (int i = 0; i < memorySizeToWrite; ++i) {
			cBuffer[getWriteIndex()] = outerBuffer[i];
			++memoryUsed;
		}
		return true;
	}
}
