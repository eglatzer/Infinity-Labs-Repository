package com.ilad.circularbuffer;

import javax.crypto.IllegalBlockSizeException;

public class CircularBuffer<E> {
	private E[] circularBuffer;
	private int memCapacity;
	private int memUsed = 0;
	private int readIndex = 0;

	// Constructor
	@SuppressWarnings("unchecked")
	public CircularBuffer(int memCapacity_) throws IllegalBlockSizeException {
		if (0 >= memCapacity_) {
			throw new IllegalBlockSizeException("memCapacity_ should be positive!");
		}
		Object temp = new Object[memCapacity_];
		circularBuffer = (E[]) temp;
		memCapacity = memCapacity_;
	}

	// Getters
	public int getMemCapacity() {
		return memCapacity;
	}

	public int getMemUsed() {
		return memUsed;
	}

	public int getMemFree() {
		return memCapacity - memUsed;
	}

	private int getWriteIndex() {
		return (readIndex + memUsed) % memCapacity;
	}

	// Other Methods
	public boolean read(E[] outerBuffer, int memToRead) {
		if(memUsed < memToRead || outerBuffer.length < memToRead) {
			return false;
		}
		for(int i = 0; i < memToRead; ++i) {
			outerBuffer[i] = circularBuffer[readIndex];
			--memUsed;
			readIndex = (readIndex + 1) % memCapacity;
		}
		return true;
	}

	public int write(E[] outerBuffer, int memToWrite) {
		int i = 0;
		while (0 != getMemFree() && i != outerBuffer.length && i != memToWrite) {
			circularBuffer[getWriteIndex()] = outerBuffer[i];
			++i;
			++memUsed;
		}
		return i;
	}
	
	public void printCircularBufferContent() {
		for(int i = 0; i < memUsed; ++i) {
			System.out.print(circularBuffer[(readIndex + i) % memCapacity] + " ");
		}
		System.out.println();
	}
}
